{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"prefect-hex","text":""},{"location":"#welcome","title":"Welcome!","text":"<p>Prefect integrations for interacting with Hex. </p> <p>Hex is a powerful platform for collaborative data science and analytics. For information getting started with Hex, check out Hex's quickstart guide.</p> <p>The tasks within this collection were created by a code generator using Hex's OpenAPI spec.</p> <p>Hex's REST API documentation can be found here.</p>"},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#python-setup","title":"Python setup","text":"<p>Requires an installation of Python 3.7+.</p> <p>We recommend using a Python virtual environment manager such as pipenv, conda or virtualenv.</p> <p>These tasks are designed to work with Prefect 2.0. For more information about how to use Prefect, please refer to the Prefect documentation.</p>"},{"location":"#installation","title":"Installation","text":"<p>Install <code>prefect-hex</code> with <code>pip</code>:</p> <pre><code>pip install prefect-hex\n</code></pre> <p>A list of available blocks in <code>prefect-hex</code> and their setup instructions can be found here.</p>"},{"location":"#gather-and-store-authentication","title":"Gather and store authentication","text":"<ol> <li>Create new token on https://app.hex.tech/ Settings page:</li> </ol> <ol> <li>Store token on https://app.prefect.cloud/ Blocks page:</li> </ol> <ol> <li>Copy project ID from browser URL (in red):</li> </ol>"},{"location":"#write-and-run-a-flow","title":"Write and run a flow","text":""},{"location":"#trigger-a-hex-project-run-and-wait-for-completion","title":"Trigger a Hex project run and wait for completion","text":"<pre><code>from prefect import flow\nfrom prefect_hex import HexCredentials\nfrom prefect_hex.project import trigger_project_run_and_wait_for_completion\n\n@flow\ndef trigger_project_run_and_wait_for_completion_flow(project_id: str):\n    hex_credentials = HexCredentials.load(\"hex-token\")\n    project_metadata = trigger_project_run_and_wait_for_completion(\n        project_id=project_id,\n        hex_credentials=hex_credentials\n    )\n    return project_metadata\n\ntrigger_project_run_and_wait_for_completion_flow(\n    project_id=\"012345c6-b67c-1234-1b2c-66e4ad07b9f3\"\n)\n</code></pre>"},{"location":"#run-project-get-status-cancel-run-and-get-list-of-projects","title":"Run project, get status, cancel run, and get list of projects","text":"<pre><code>from prefect import flow\nfrom prefect_hex import HexCredentials\nfrom prefect_hex.project import (\n    get_project_runs,\n    run_project,\n    get_run_status,\n    cancel_run,\n)\n\n@flow\ndef example_hex_flow():\n    # load stored credentials\n    hex_credentials = HexCredentials.load(\"hex-token\")\n\n    # run project\n    project_id='5a8591dd-4039-49df-9202-96385ba3eff8',\n    project_run = run_project(project_id=project_id, hex_credentials=hex_credentials)\n\n    # get status\n    run_id = project_run.run_id\n    project_run_status = get_run_status(\n        project_id=project_id, run_id=run_id, hex_credentials=hex_credentials\n    )\n    print(project_run_status.run_url)\n\n    # cancel run if needed\n    cancel_run(project_id=project_id, run_id=run_id, hex_credentials=hex_credentials)\n\n    # get list of project runs\n    project_runs = get_project_runs(\n        project_id=project_id, hex_credentials=hex_credentials\n    )\n\n    return project_runs\n\nexample_hex_flow()\n</code></pre> <p>For more tips on how to use tasks and flows in a Collection, check out Using Collections!</p>"},{"location":"#resources","title":"Resources","text":""},{"location":"#blog-posts","title":"Blog Posts","text":"<ul> <li>Create Observable and Reproducible Notebooks with Hex by Khuyen Tran</li> </ul>"},{"location":"#videos","title":"Videos","text":"<ul> <li>Create Observable and Reproducible Notebooks with Hex: Why Hex (Part 1)</li> </ul> <p>If you encounter any bugs while using <code>prefect-hex</code>, feel free to open an issue in the prefect-hex repository.</p> <p>If you have any questions or issues while using <code>prefect-hex</code>, you can find help in either the Prefect Discourse forum or the Prefect Slack community.</p> <p>Feel free to star or watch <code>prefect-hex</code> for updates too!</p>"},{"location":"#contributing","title":"Contributing","text":"<p>-<code>``bash -git clone https://github.com/PrefectHQ/prefect-hex.git If you'd like to help contribute to fix an issue or add a feature to</code>prefect-hex`, please propose changes through a pull request from a fork of the repository.</p> <p>-cd prefect-hex/ Here are the steps:</p> <ol> <li>Fork the repository</li> <li>Clone the forked repository</li> <li>Install the repository and its dependencies: <pre><code> pip install -e \".[dev]\"\n</code></pre></li> <li>Make desired changes</li> <li>Add tests</li> <li>Insert an entry to CHANGELOG.md</li> <li>Install <code>pre-commit</code> to perform quality checks prior to commit: <code>pre-commit install</code></li> <li><code>git commit</code>, <code>git push</code>, and create a pull request install</li> </ol>"},{"location":"credentials/","title":"Credentials","text":""},{"location":"credentials/#prefect_hex.credentials","title":"<code>prefect_hex.credentials</code>","text":"<p>Credential classes used to perform authenticated interactions with Hex</p>"},{"location":"credentials/#prefect_hex.credentials.HexCredentials","title":"<code> HexCredentials        </code>  <code>pydantic-model</code>","text":"<p>Block used to manage Hex authentication.</p> <p>Attributes:</p> Name Type Description <code>domain</code> <code>str</code> <p>Domain to make API requests against.</p> <code>token</code> <code>SecretStr</code> <p>The token to authenticate with Hex.</p> <p>Examples:</p> <p>Load stored Hex credentials: <pre><code>from prefect_hex import HexCredentials\n\nhex_credentials_block = HexCredentials.load(\"BLOCK_NAME\")\n</code></pre></p> Source code in <code>prefect_hex/credentials.py</code> <pre><code>class HexCredentials(Block):\n    \"\"\"\n    Block used to manage Hex authentication.\n\n    Attributes:\n        domain: Domain to make API requests against.\n        token: The token to authenticate with Hex.\n\n\n    Examples:\n        Load stored Hex credentials:\n        ```python\n        from prefect_hex import HexCredentials\n\n        hex_credentials_block = HexCredentials.load(\"BLOCK_NAME\")\n        ```\n    \"\"\"\n\n    _block_type_name = \"Hex Credentials\"\n    _logo_url = \"https://images.ctfassets.net/gm98wzqotmnx/3biMverMLGiDA7y5fkqKZF/4b7747052b59fa8182a9686b88ea9541/Hex_Purple__for_light_backgrounds_.png?h=250\"  # noqa\n    _documentation_url = \"https://prefecthq.github.io/prefect-hex/credentials/#prefect_hex.credentials.HexCredentials\"  # noqa\n\n    domain: str = Field(\n        default=\"app.hex.tech\", description=\"Domain to make API requests against.\"\n    )\n    token: SecretStr = Field(default=..., description=\"Token used for authentication.\")\n\n    def get_client(self) -&gt; AsyncClient:\n        \"\"\"\n        Gets a Hex REST AsyncClient.\n\n        Returns:\n            A Hex REST AsyncClient.\n\n        Example:\n            Gets a Hex REST AsyncClient.\n            ```python\n            from prefect import flow\n            from prefect_hex import HexCredentials\n\n            @flow\n            def example_get_client_flow():\n                token = \"consumer_key\"\n                hex_credentials = HexCredentials(token=token)\n                client = hex_credentials.get_client()\n                return client\n\n            example_get_client_flow()\n            ```\n        \"\"\"\n        client_kwargs = {\n            \"base_url\": f\"https://{self.domain}/api/v1\",\n            \"headers\": {\"Authorization\": f\"Bearer {self.token.get_secret_value()}\"},\n        }\n        client = AsyncClient(**client_kwargs)\n        return client\n</code></pre>"},{"location":"credentials/#prefect_hex.credentials.HexCredentials.domain","title":"<code>domain: str</code>  <code>pydantic-field</code>","text":"<p>Domain to make API requests against.</p>"},{"location":"credentials/#prefect_hex.credentials.HexCredentials.token","title":"<code>token: SecretStr</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>Token used for authentication.</p>"},{"location":"credentials/#prefect_hex.credentials.HexCredentials.__json_encoder__","title":"<code>__json_encoder__</code>  <code>special</code> <code>staticmethod</code>","text":"<p>partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.</p>"},{"location":"credentials/#prefect_hex.credentials.HexCredentials.get_client","title":"<code>get_client</code>","text":"<p>Gets a Hex REST AsyncClient.</p> <p>Returns:</p> Type Description <code>AsyncClient</code> <p>A Hex REST AsyncClient.</p> <p>Examples:</p> <p>Gets a Hex REST AsyncClient. <pre><code>from prefect import flow\nfrom prefect_hex import HexCredentials\n\n@flow\ndef example_get_client_flow():\n    token = \"consumer_key\"\n    hex_credentials = HexCredentials(token=token)\n    client = hex_credentials.get_client()\n    return client\n\nexample_get_client_flow()\n</code></pre></p> Source code in <code>prefect_hex/credentials.py</code> <pre><code>def get_client(self) -&gt; AsyncClient:\n    \"\"\"\n    Gets a Hex REST AsyncClient.\n\n    Returns:\n        A Hex REST AsyncClient.\n\n    Example:\n        Gets a Hex REST AsyncClient.\n        ```python\n        from prefect import flow\n        from prefect_hex import HexCredentials\n\n        @flow\n        def example_get_client_flow():\n            token = \"consumer_key\"\n            hex_credentials = HexCredentials(token=token)\n            client = hex_credentials.get_client()\n            return client\n\n        example_get_client_flow()\n        ```\n    \"\"\"\n    client_kwargs = {\n        \"base_url\": f\"https://{self.domain}/api/v1\",\n        \"headers\": {\"Authorization\": f\"Bearer {self.token.get_secret_value()}\"},\n    }\n    client = AsyncClient(**client_kwargs)\n    return client\n</code></pre>"},{"location":"project/","title":"Project","text":""},{"location":"project/#prefect_hex.project","title":"<code>prefect_hex.project</code>","text":"<p>This is a module containing tasks for interacting with Hex projects</p>"},{"location":"project/#prefect_hex.project.cancel_run","title":"<code>cancel_run</code>  <code>async</code>","text":"<p>Cancel a project run.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Project ID associated with the run to cancel.</p> required <code>run_id</code> <code>str</code> <p>Run ID of the run to cancel.</p> required <code>hex_credentials</code> <code>HexCredentials</code> <p>Credentials to use for authentication with Hex.</p> required Source code in <code>prefect_hex/project.py</code> <pre><code>@task\nasync def cancel_run(\n    project_id: str,\n    run_id: str,\n    hex_credentials: HexCredentials,\n) -&gt; None:  # pragma: no cover\n    \"\"\"\n    Cancel a project run.\n\n    Args:\n        project_id:\n            Project ID associated with the run to cancel.\n        run_id:\n            Run ID of the run to cancel.\n        hex_credentials:\n            Credentials to use for authentication with Hex.\n    \"\"\"  # noqa\n    endpoint = f\"/project/{project_id}/run/{run_id}\"  # noqa\n\n    response = await execute_endpoint.fn(\n        endpoint,\n        hex_credentials,\n        http_method=HTTPMethod.DELETE,\n    )\n\n    # Handles any errors returned by the API\n    _unpack_contents(response)\n</code></pre>"},{"location":"project/#prefect_hex.project.get_project_runs","title":"<code>get_project_runs</code>  <code>async</code>","text":"<p>Get the status of the API-triggered runs of a project.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Project ID to get runs for.</p> required <code>hex_credentials</code> <code>HexCredentials</code> <p>Credentials to use for authentication with Hex.</p> required <code>limit</code> <code>Optional[prefect_hex.models.project.PageSize]</code> <p>Number of results to fetch per page for paginated requests.</p> <code>None</code> <code>offset</code> <code>Optional[prefect_hex.models.project.Offset]</code> <p>Offset for paginated requests.</p> <code>None</code> <code>status_filter</code> <code>Optional[prefect_hex.models.project.ProjectRunStatus]</code> <p>Current status of a project run.</p> <code>None</code> <p>Returns:</p> Type Description <code>ProjectRunsResponsePayload</code> <p>Details of all the retrieved runs.</p> Source code in <code>prefect_hex/project.py</code> <pre><code>@task\nasync def get_project_runs(\n    project_id: str,\n    hex_credentials: HexCredentials,\n    limit: Optional[models.PageSize] = None,\n    offset: Optional[models.Offset] = None,\n    status_filter: Optional[models.ProjectRunStatus] = None,\n) -&gt; models.ProjectRunsResponsePayload:  # pragma: no cover\n    \"\"\"\n    Get the status of the API-triggered runs of a project.\n\n    Args:\n        project_id:\n            Project ID to get runs for.\n        hex_credentials:\n            Credentials to use for authentication with Hex.\n        limit:\n            Number of results to fetch per page for paginated requests.\n        offset:\n            Offset for paginated requests.\n        status_filter:\n            Current status of a project run.\n\n    Returns:\n        Details of all the retrieved runs.\n    \"\"\"  # noqa\n    endpoint = f\"/project/{project_id}/runs\"  # noqa\n\n    params = {\n        \"limit\": limit,\n        \"offset\": offset,\n        \"statusFilter\": status_filter.value if status_filter is not None else None,\n    }\n\n    response = await execute_endpoint.fn(\n        endpoint,\n        hex_credentials,\n        http_method=HTTPMethod.GET,\n        params=params,\n    )\n\n    contents = _unpack_contents(response)\n    return models.ProjectRunsResponsePayload.parse_obj(contents)\n</code></pre>"},{"location":"project/#prefect_hex.project.get_run_status","title":"<code>get_run_status</code>  <code>async</code>","text":"<p>Get the status of a project run.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Project ID associated with the run to get the status of.</p> required <code>run_id</code> <code>str</code> <p>Run ID of the run to get the status of.</p> required <code>hex_credentials</code> <code>HexCredentials</code> <p>Credentials to use for authentication with Hex.</p> required <p>Returns:</p> Type Description <code>ProjectStatusResponsePayload</code> <p>Information about the requested run.</p> Source code in <code>prefect_hex/project.py</code> <pre><code>@task\nasync def get_run_status(\n    project_id: str,\n    run_id: str,\n    hex_credentials: HexCredentials,\n) -&gt; models.ProjectStatusResponsePayload:  # pragma: no cover\n    \"\"\"\n    Get the status of a project run.\n\n    Args:\n        project_id:\n            Project ID associated with the run to get the status of.\n        run_id:\n            Run ID of the run to get the status of.\n        hex_credentials:\n            Credentials to use for authentication with Hex.\n\n    Returns:\n        Information about the requested run.\n    \"\"\"  # noqa\n    endpoint = f\"/project/{project_id}/run/{run_id}\"  # noqa\n\n    response = await execute_endpoint.fn(\n        endpoint,\n        hex_credentials,\n        http_method=HTTPMethod.GET,\n    )\n\n    contents = _unpack_contents(response)\n    return models.ProjectStatusResponsePayload.parse_obj(contents)\n</code></pre>"},{"location":"project/#prefect_hex.project.run_project","title":"<code>run_project</code>  <code>async</code>","text":"<p>Trigger a run of the latest published version of a project.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Project ID to run.</p> required <code>hex_credentials</code> <code>HexCredentials</code> <p>Credentials to use for authentication with Hex.</p> required <code>input_params</code> <code>Optional[Dict]</code> <p>Optional input parameter value map for this project run, e.g. <pre><code>{\"text_input_1\": \"Hello World\", \"numeric_input_1\": 123}\n</code></pre></p> <code>None</code> <code>dry_run</code> <code>bool</code> <p>If specified, perform a dry run without actually executing the project.</p> <code>False</code> <code>update_cache</code> <code>bool</code> <p>When true, this run will update the cached state of the published app with the latest run results. Additionally, any SQL cells that have caching enabled will be re-executed as part of this run. Note that this cannot be set to true if custom input parameters are provided.</p> <code>False</code> <p>Returns:</p> Type Description <code>ProjectRunResponsePayload</code> <p>Information about the triggered project run.</p> Source code in <code>prefect_hex/project.py</code> <pre><code>@task\nasync def run_project(\n    project_id: str,\n    hex_credentials: HexCredentials,\n    input_params: Optional[Dict] = None,\n    dry_run: bool = False,\n    update_cache: bool = False,\n) -&gt; models.ProjectRunResponsePayload:  # pragma: no cover\n    \"\"\"\n    Trigger a run of the latest published version of a project.\n\n    Args:\n        project_id:\n            Project ID to run.\n        hex_credentials:\n            Credentials to use for authentication with Hex.\n        input_params:\n            Optional input parameter value map for this project run, e.g.\n            ```\n            {\"text_input_1\": \"Hello World\", \"numeric_input_1\": 123}\n            ```\n        dry_run:\n            If specified, perform a dry run without actually executing the project.\n        update_cache:\n            When true, this run will update the cached state of the published app\n            with the latest run results. Additionally, any SQL cells\n            that have caching enabled will be re-executed as part of\n            this run. Note that this cannot be set to true if custom\n            input parameters are provided.\n\n    Returns:\n        Information about the triggered project run.\n    \"\"\"  # noqa\n    endpoint = f\"/project/{project_id}/run\"  # noqa\n\n    response = await execute_endpoint.fn(\n        endpoint,\n        hex_credentials,\n        http_method=HTTPMethod.POST,\n        json=models.RunProjectRequestBody(\n            dryRun=dry_run, inputParams=input_params, updateCache=update_cache\n        ).dict(by_alias=True),\n    )\n\n    contents = _unpack_contents(response)\n    return models.ProjectRunResponsePayload.parse_obj(contents)\n</code></pre>"},{"location":"project/#prefect_hex.project.trigger_project_run_and_wait_for_completion","title":"<code>trigger_project_run_and_wait_for_completion</code>  <code>async</code>","text":"<p>Flow that triggers a project run and waits for the triggered run to complete.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Project ID to run.</p> required <code>hex_credentials</code> <code>HexCredentials</code> <p>Credentials to use for authentication with Hex.</p> required <code>input_params</code> <code>Optional[Dict]</code> <p>Optional input parameter value map for this project run, e.g. <pre><code>{\"text_input_1\": \"Hello World\", \"numeric_input_1\": 123}\n</code></pre></p> <code>None</code> <code>update_cache</code> <code>bool</code> <p>When true, this run will update the cached state of the published app with the latest run results. Additionally, any SQL cells that have caching enabled will be re-executed as part of this run. Note that this cannot be set to true if custom input parameters are provided.</p> <code>False</code> <code>max_wait_seconds</code> <code>int</code> <p>Maximum number of seconds to wait for the entire flow to complete.</p> <code>900</code> <code>poll_frequency_seconds</code> <code>int</code> <p>Number of seconds to wait in between checks for run completion.</p> <code>10</code> <p>Returns:</p> Type Description <code>ProjectRunResponsePayload</code> <p>Information about the triggered project run.</p> <p>Examples:</p> <p>Trigger a Hex project run and wait for completion as a stand-alone flow. <pre><code>import asyncio\nfrom prefect_hex import HexCredentials\nfrom prefect_hex.project import trigger_project_run_and_wait_for_completion\n\nasyncio.run(\n    trigger_sync_run_and_wait_for_completion(\n        hex_credentials=HexCredentials(\n            token=\"1abc0d23-1234-1a2b-abc3-12ab456c7d8e\"\n        ),\n        project_id=\"012345c6-b67c-1234-1b2c-66e4ad07b9f3\",\n        max_wait_seconds=1800,\n        poll_frequency_seconds=5,\n    )\n)\n</code></pre></p> <p>Trigger a Hex project run and wait for completion as a subflow. <pre><code>from prefect import flow\nfrom prefect_hex import HexCredentials\nfrom prefect_hex.project import trigger_project_run_and_wait_for_completion\n\n@flow\ndef trigger_project_run_and_wait_for_completion_flow(project_id: str):\n    hex_credentials = HexCredentials.load(\"hex-token\")\n    project_metadata = trigger_project_run_and_wait_for_completion(\n        project_id=project_id,\n        hex_credentials=hex_credentials\n    )\n    return project_metadata\n\ntrigger_project_run_and_wait_for_completion_flow(\n    project_id=\"012345c6-b67c-1234-1b2c-66e4ad07b9f3\"\n)\n</code></pre></p> Source code in <code>prefect_hex/project.py</code> <pre><code>@flow\nasync def trigger_project_run_and_wait_for_completion(\n    project_id: str,\n    hex_credentials: HexCredentials,\n    input_params: Optional[Dict] = None,\n    update_cache: bool = False,\n    max_wait_seconds: int = 900,\n    poll_frequency_seconds: int = 10,\n) -&gt; models.ProjectRunResponsePayload:\n    \"\"\"\n    Flow that triggers a project run and waits for the triggered run to complete.\n\n    Args:\n        project_id:\n            Project ID to run.\n        hex_credentials:\n            Credentials to use for authentication with Hex.\n        input_params:\n            Optional input parameter value map for this project run, e.g.\n            ```\n            {\"text_input_1\": \"Hello World\", \"numeric_input_1\": 123}\n            ```\n        update_cache:\n            When true, this run will update the cached state of the published app\n            with the latest run results. Additionally, any SQL cells\n            that have caching enabled will be re-executed as part of\n            this run. Note that this cannot be set to true if custom\n            input parameters are provided.\n        max_wait_seconds: Maximum number of seconds to wait for the entire\n            flow to complete.\n        poll_frequency_seconds: Number of seconds to wait in between checks for\n            run completion.\n\n    Returns:\n        Information about the triggered project run.\n\n    Examples:\n        Trigger a Hex project run and wait for completion as a stand-alone flow.\n        ```python\n        import asyncio\n        from prefect_hex import HexCredentials\n        from prefect_hex.project import trigger_project_run_and_wait_for_completion\n\n        asyncio.run(\n            trigger_sync_run_and_wait_for_completion(\n                hex_credentials=HexCredentials(\n                    token=\"1abc0d23-1234-1a2b-abc3-12ab456c7d8e\"\n                ),\n                project_id=\"012345c6-b67c-1234-1b2c-66e4ad07b9f3\",\n                max_wait_seconds=1800,\n                poll_frequency_seconds=5,\n            )\n        )\n        ```\n\n        Trigger a Hex project run and wait for completion as a subflow.\n        ```python\n        from prefect import flow\n        from prefect_hex import HexCredentials\n        from prefect_hex.project import trigger_project_run_and_wait_for_completion\n\n        @flow\n        def trigger_project_run_and_wait_for_completion_flow(project_id: str):\n            hex_credentials = HexCredentials.load(\"hex-token\")\n            project_metadata = trigger_project_run_and_wait_for_completion(\n                project_id=project_id,\n                hex_credentials=hex_credentials\n            )\n            return project_metadata\n\n        trigger_project_run_and_wait_for_completion_flow(\n            project_id=\"012345c6-b67c-1234-1b2c-66e4ad07b9f3\"\n        )\n        ```\n    \"\"\"\n    logger = get_run_logger()\n\n    project_run_future = await run_project.submit(\n        project_id=project_id,\n        hex_credentials=hex_credentials,\n        input_params=input_params,\n        update_cache=update_cache,\n    )\n    project_run = await project_run_future.result()\n    run_id = project_run.run_id\n\n    logger.info(\n        \"Started project %s run %s; visit %s to view the run.\",\n        repr(project_id),\n        repr(run_id),\n        str(project_run.run_status_url),\n    )\n\n    project_status, project_metadata = await wait_for_project_run_completion(\n        project_id=project_id,\n        run_id=run_id,\n        hex_credentials=hex_credentials,\n        max_wait_seconds=max_wait_seconds,\n        poll_frequency_seconds=poll_frequency_seconds,\n    )\n\n    if project_status == models.ProjectRunStatus.completed:\n        return project_metadata\n    else:\n        raise TERMINAL_STATUS_EXCEPTIONS.get(project_status, HexProjectRunError)(\n            f\"Project {project_id!r} run {run_id!r} \"\n            f\"was unsuccessful with {project_status.value!r} status\"\n        )\n</code></pre>"},{"location":"project/#prefect_hex.project.wait_for_project_run_completion","title":"<code>wait_for_project_run_completion</code>  <code>async</code>","text":"<p>Flow that waits for the triggered project run to complete.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Project ID to watch.</p> required <code>run_id</code> <code>str</code> <p>Run ID to wait for.</p> required <code>hex_credentials</code> <code>HexCredentials</code> <p>Credentials to use for authentication with Hex.</p> required <code>max_wait_seconds</code> <code>int</code> <p>Maximum number of seconds to wait for the entire flow to complete.</p> <code>900</code> <code>poll_frequency_seconds</code> <code>int</code> <p>Number of seconds to wait in between checks for run completion.</p> <code>10</code> <p>Returns:</p> Type Description <code>Tuple[prefect_hex.models.project.ProjectRunStatus, prefect_hex.models.project.ProjectStatusResponsePayload]</code> <p>The status of the project run and the metadata associated with the run.</p> <p>Examples:</p> <p>Wait for completion of a project run as a subflow. <pre><code>from prefect import flow\nfrom prefect_hex import HexCredentials\nfrom prefect_hex.project import wait_for_project_run_completion\n\n@flow\ndef wait_for_project_run_completion_flow(project_id: str, run_id: str):\n    hex_credentials = HexCredentials.load(\"hex-token\")\n    project_status, project_metadata = wait_for_project_run_completion(\n        project_id=project_id,\n        run_id=run_id,\n        hex_credentials=hex_credentials\n    )\n    return project_status, project_metadata\n\nwait_for_project_run_completion_flow(\n    project_id=\"012345c6-b67c-1234-1b2c-66e4ad07b9f3\",\n    run_id=\"654321c6-b67c-1234-1b2c-66e4ad07b9f3\",\n)\n</code></pre></p> Source code in <code>prefect_hex/project.py</code> <pre><code>@flow\nasync def wait_for_project_run_completion(\n    project_id: str,\n    run_id: str,\n    hex_credentials: HexCredentials,\n    max_wait_seconds: int = 900,\n    poll_frequency_seconds: int = 10,\n) -&gt; Tuple[models.ProjectRunStatus, models.ProjectStatusResponsePayload]:\n    \"\"\"\n    Flow that waits for the triggered project run to complete.\n\n    Args:\n        project_id:\n            Project ID to watch.\n        run_id:\n            Run ID to wait for.\n        hex_credentials:\n            Credentials to use for authentication with Hex.\n        max_wait_seconds: Maximum number of seconds to wait for the entire\n            flow to complete.\n        poll_frequency_seconds: Number of seconds to wait in between checks for\n            run completion.\n\n    Returns:\n        The status of the project run and the metadata associated with the run.\n\n    Examples:\n        Wait for completion of a project run as a subflow.\n        ```python\n        from prefect import flow\n        from prefect_hex import HexCredentials\n        from prefect_hex.project import wait_for_project_run_completion\n\n        @flow\n        def wait_for_project_run_completion_flow(project_id: str, run_id: str):\n            hex_credentials = HexCredentials.load(\"hex-token\")\n            project_status, project_metadata = wait_for_project_run_completion(\n                project_id=project_id,\n                run_id=run_id,\n                hex_credentials=hex_credentials\n            )\n            return project_status, project_metadata\n\n        wait_for_project_run_completion_flow(\n            project_id=\"012345c6-b67c-1234-1b2c-66e4ad07b9f3\",\n            run_id=\"654321c6-b67c-1234-1b2c-66e4ad07b9f3\",\n        )\n        ```\n    \"\"\"\n    logger = get_run_logger()\n    seconds_waited_for_run_completion = 0\n    wait_for = []\n\n    while seconds_waited_for_run_completion &lt;= max_wait_seconds:\n        project_future = await get_run_status.submit(\n            project_id=project_id,\n            run_id=run_id,\n            hex_credentials=hex_credentials,\n            wait_for=wait_for,\n        )\n        wait_for = [project_future]\n\n        project_metadata = await project_future.result()\n        project_status = project_metadata.status\n        if project_status in TERMINAL_STATUS_EXCEPTIONS.keys():\n            return project_status, project_metadata\n\n        logger.debug(\n            \"Waiting on project %s run %s with sync status %s for %s seconds\",\n            repr(project_id),\n            repr(run_id),\n            repr(project_status.value),\n            poll_frequency_seconds,\n        )\n        await asyncio.sleep(poll_frequency_seconds)\n        seconds_waited_for_run_completion += poll_frequency_seconds\n\n    raise HexProjectRunTimedOut(\n        f\"Max wait time of {max_wait_seconds} seconds exceeded while waiting \"\n        f\"for project {project_id!r} run {run_id!r}\"\n    )\n</code></pre>"},{"location":"rest/","title":"Rest","text":""},{"location":"rest/#prefect_hex.rest","title":"<code>prefect_hex.rest</code>","text":"<p>This is a module containing generic REST tasks.</p>"},{"location":"rest/#prefect_hex.rest.HTTPMethod","title":"<code> HTTPMethod        </code>","text":"<p>Available HTTP request methods.</p> Source code in <code>prefect_hex/rest.py</code> <pre><code>class HTTPMethod(Enum):\n    \"\"\"\n    Available HTTP request methods.\n    \"\"\"\n\n    GET = \"get\"\n    POST = \"post\"\n    PUT = \"put\"\n    DELETE = \"delete\"\n    PATCH = \"patch\"\n</code></pre>"},{"location":"rest/#prefect_hex.rest.execute_endpoint","title":"<code>execute_endpoint</code>  <code>async</code>","text":"<p>Generic function for executing REST endpoints.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>The endpoint route.</p> required <code>hex_credentials</code> <code>HexCredentials</code> <p>Credentials to use for authentication with Hex.</p> required <code>http_method</code> <code>HTTPMethod</code> <p>Either GET, POST, PUT, DELETE, or PATCH.</p> <code>&lt;HTTPMethod.GET: 'get'&gt;</code> <code>params</code> <code>Dict[str, Any]</code> <p>URL query parameters in the request.</p> <code>None</code> <code>json</code> <code>Dict[str, Any]</code> <p>JSON serializable object to include in the body of the request.</p> <code>None</code> <code>**kwargs</code> <code>Dict[str, Any]</code> <p>Additional keyword arguments to pass.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>The httpx.Response from interacting with the endpoint.</p> <p>Examples:</p> <p>Queries project runs for a given project ID. <pre><code>from prefect import flow\nfrom prefect_hex import HexCredentials\nfrom prefect_hex.rest import execute_endpoint\n\n@flow\ndef example_execute_endpoint_flow():\n    endpoint = f\"/project/5a8591dd-4039-49df-9202-96385ba3eff8/runs\"\n    hex_credentials = HexCredentials(token=\"a1b2c3d4\")\n    params = dict(limit=100)\n\n    response = execute_endpoint(endpoint, hex_credentials, params=params)\n    return response.json()\n\nexample_execute_endpoint_flow()\n</code></pre></p> Source code in <code>prefect_hex/rest.py</code> <pre><code>@task\nasync def execute_endpoint(\n    endpoint: str,\n    hex_credentials: \"HexCredentials\",\n    http_method: HTTPMethod = HTTPMethod.GET,\n    params: Dict[str, Any] = None,\n    json: Dict[str, Any] = None,\n    **kwargs: Dict[str, Any],\n) -&gt; httpx.Response:\n    \"\"\"\n    Generic function for executing REST endpoints.\n\n    Args:\n        endpoint: The endpoint route.\n        hex_credentials: Credentials to use for authentication with Hex.\n        http_method: Either GET, POST, PUT, DELETE, or PATCH.\n        params: URL query parameters in the request.\n        json: JSON serializable object to include in the body of the request.\n        **kwargs: Additional keyword arguments to pass.\n\n    Returns:\n        The httpx.Response from interacting with the endpoint.\n\n    Examples:\n        Queries project runs for a given project ID.\n        ```python\n        from prefect import flow\n        from prefect_hex import HexCredentials\n        from prefect_hex.rest import execute_endpoint\n\n        @flow\n        def example_execute_endpoint_flow():\n            endpoint = f\"/project/5a8591dd-4039-49df-9202-96385ba3eff8/runs\"\n            hex_credentials = HexCredentials(token=\"a1b2c3d4\")\n            params = dict(limit=100)\n\n            response = execute_endpoint(endpoint, hex_credentials, params=params)\n            return response.json()\n\n        example_execute_endpoint_flow()\n        ```\n    \"\"\"\n    if isinstance(http_method, HTTPMethod):\n        http_method = http_method.value\n\n    if params is not None:\n        stripped_params = strip_kwargs(**params)\n    else:\n        stripped_params = None\n\n    if json is not None:\n        kwargs[\"json\"] = strip_kwargs(**json)\n\n    async with hex_credentials.get_client() as client:\n        response = await getattr(client, http_method)(\n            endpoint, params=stripped_params, **kwargs\n        )\n\n    return response\n</code></pre>"},{"location":"rest/#prefect_hex.rest.serialize_model","title":"<code>serialize_model</code>","text":"<p>Recursively serializes <code>pydantic.BaseModel</code> into JSON; returns original obj if not a <code>BaseModel</code>.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>Input object to serialize.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Serialized version of object.</p> Source code in <code>prefect_hex/rest.py</code> <pre><code>def serialize_model(obj: Any) -&gt; Any:\n    \"\"\"\n    Recursively serializes `pydantic.BaseModel` into JSON;\n    returns original obj if not a `BaseModel`.\n\n    Args:\n        obj: Input object to serialize.\n\n    Returns:\n        Serialized version of object.\n    \"\"\"\n    if isinstance(obj, list):\n        return [serialize_model(o) for o in obj]\n    elif isinstance(obj, Dict):\n        return {k: serialize_model(v) for k, v in obj.items()}\n\n    if isinstance(obj, BaseModel):\n        obj = obj.dict()\n    return obj\n</code></pre>"},{"location":"rest/#prefect_hex.rest.strip_kwargs","title":"<code>strip_kwargs</code>","text":"<p>Recursively drops keyword arguments if value is None, and serializes any <code>pydantic.BaseModel</code> types.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Dict</code> <p>Input keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Dict</code> <p>Stripped version of kwargs.</p> Source code in <code>prefect_hex/rest.py</code> <pre><code>def strip_kwargs(**kwargs: Dict) -&gt; Dict:\n    \"\"\"\n    Recursively drops keyword arguments if value is None,\n    and serializes any `pydantic.BaseModel` types.\n\n    Args:\n        **kwargs: Input keyword arguments.\n\n    Returns:\n        Stripped version of kwargs.\n    \"\"\"\n    stripped_dict = {}\n    for k, v in kwargs.items():\n        v = serialize_model(v)\n        if isinstance(v, dict):\n            v = strip_kwargs(**v)\n        if v is not None:\n            stripped_dict[k] = v\n    return stripped_dict or {}\n</code></pre>"},{"location":"models/project/","title":"Project","text":""},{"location":"models/project/#prefect_hex.models.project","title":"<code>prefect_hex.models.project</code>","text":""},{"location":"models/project/#prefect_hex.models.project.Offset","title":"<code> Offset        </code>  <code>pydantic-model</code>","text":"Source code in <code>prefect_hex/models/project.py</code> <pre><code>class Offset(BaseModel):\n    class Config:\n        extra = Extra.allow\n        allow_mutation = False\n\n    __root__: int = Field(\n        default=..., description=\"Offset for paginated requests.\", ge=0\n    )\n</code></pre>"},{"location":"models/project/#prefect_hex.models.project.Offset.__root__","title":"<code>__root__: ConstrainedIntValue</code>  <code>pydantic-field</code> <code>required</code> <code>special</code>","text":"<p>Offset for paginated requests.</p>"},{"location":"models/project/#prefect_hex.models.project.PageSize","title":"<code> PageSize        </code>  <code>pydantic-model</code>","text":"Source code in <code>prefect_hex/models/project.py</code> <pre><code>class PageSize(BaseModel):\n    class Config:\n        extra = Extra.allow\n        allow_mutation = False\n\n    __root__: int = Field(\n        default=...,\n        description=\"Number of results to fetch per page for paginated requests.\",\n        ge=1,\n        le=100,\n    )\n</code></pre>"},{"location":"models/project/#prefect_hex.models.project.PageSize.__root__","title":"<code>__root__: ConstrainedIntValue</code>  <code>pydantic-field</code> <code>required</code> <code>special</code>","text":"<p>Number of results to fetch per page for paginated requests.</p>"},{"location":"models/project/#prefect_hex.models.project.ProjectRunResponsePayload","title":"<code> ProjectRunResponsePayload        </code>  <code>pydantic-model</code>","text":"<p>Response format returned by the runProject endpoint.</p> Source code in <code>prefect_hex/models/project.py</code> <pre><code>class ProjectRunResponsePayload(BaseModel):\n    \"\"\"\n    Response format returned by the runProject endpoint.\n    \"\"\"\n\n    class Config:\n        extra = Extra.allow\n        allow_mutation = False\n\n    project_id: str = Field(\n        default=..., alias=\"projectId\", description=\"Unique ID for a Hex project.\"\n    )\n    run_id: str = Field(\n        default=..., alias=\"runId\", description=\"Unique ID for a run of a Hex project.\"\n    )\n    run_status_url: HttpUrl = Field(\n        default=...,\n        alias=\"runStatusUrl\",\n        description=\"URL to query the status of the project run via the Hex API.\",\n    )\n    run_url: HttpUrl = Field(\n        default=...,\n        alias=\"runUrl\",\n        description=\"URL to view the current progress of the project run in the Hex UI.\",\n    )\n    trace_id: str = Field(\n        default=...,\n        alias=\"traceId\",\n        description=(\n            \"Hex trace ID to identify an API request. Provide this value to hex support\"\n            \" with any API issues you encounter.\"\n        ),\n    )\n</code></pre>"},{"location":"models/project/#prefect_hex.models.project.ProjectRunResponsePayload.project_id","title":"<code>project_id: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>Unique ID for a Hex project.</p>"},{"location":"models/project/#prefect_hex.models.project.ProjectRunResponsePayload.run_id","title":"<code>run_id: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>Unique ID for a run of a Hex project.</p>"},{"location":"models/project/#prefect_hex.models.project.ProjectRunResponsePayload.run_status_url","title":"<code>run_status_url: HttpUrl</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>URL to query the status of the project run via the Hex API.</p>"},{"location":"models/project/#prefect_hex.models.project.ProjectRunResponsePayload.run_url","title":"<code>run_url: HttpUrl</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>URL to view the current progress of the project run in the Hex UI.</p>"},{"location":"models/project/#prefect_hex.models.project.ProjectRunResponsePayload.trace_id","title":"<code>trace_id: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>Hex trace ID to identify an API request. Provide this value to hex support with any API issues you encounter.</p>"},{"location":"models/project/#prefect_hex.models.project.ProjectRunStatus","title":"<code> ProjectRunStatus        </code>","text":"<p>Current status of a project run.</p> Source code in <code>prefect_hex/models/project.py</code> <pre><code>class ProjectRunStatus(Enum):\n    \"\"\"\n    Current status of a project run.\n    \"\"\"\n\n    pending = \"PENDING\"\n    running = \"RUNNING\"\n    errored = \"ERRORED\"\n    completed = \"COMPLETED\"\n    killed = \"KILLED\"\n    unabletoallocatekernel = \"UNABLE_TO_ALLOCATE_KERNEL\"\n</code></pre>"},{"location":"models/project/#prefect_hex.models.project.ProjectRunsResponsePayload","title":"<code> ProjectRunsResponsePayload        </code>  <code>pydantic-model</code>","text":"<p>Response format returned by the getProjectRuns endpoint.</p> Source code in <code>prefect_hex/models/project.py</code> <pre><code>class ProjectRunsResponsePayload(BaseModel):\n    \"\"\"\n    Response format returned by the getProjectRuns endpoint.\n    \"\"\"\n\n    class Config:\n        extra = Extra.allow\n        allow_mutation = False\n\n    next_page: Optional[HttpUrl] = Field(\n        None,\n        alias=\"nextPage\",\n        description=\"URL to fetch the next page of results for a paginated API request.\",\n    )\n    previous_page: Optional[HttpUrl] = Field(\n        None,\n        alias=\"previousPage\",\n        description=\"URL to fetch the previous page of results for a paginated API request.\",\n    )\n    runs: List[ProjectStatusResponsePayload] = Field(\n        default=...,\n        description=(\n            \"Array of run status payloads in the same format returned by the\"\n            \" `GetRunStatus` endpoint.\"\n        ),\n    )\n    trace_id: str = Field(\n        default=...,\n        alias=\"traceId\",\n        description=(\n            \"Hex trace ID to identify an API request. Provide this value to hex support\"\n            \" with any API issues you encounter.\"\n        ),\n    )\n</code></pre>"},{"location":"models/project/#prefect_hex.models.project.ProjectRunsResponsePayload.next_page","title":"<code>next_page: HttpUrl</code>  <code>pydantic-field</code>","text":"<p>URL to fetch the next page of results for a paginated API request.</p>"},{"location":"models/project/#prefect_hex.models.project.ProjectRunsResponsePayload.previous_page","title":"<code>previous_page: HttpUrl</code>  <code>pydantic-field</code>","text":"<p>URL to fetch the previous page of results for a paginated API request.</p>"},{"location":"models/project/#prefect_hex.models.project.ProjectRunsResponsePayload.runs","title":"<code>runs: List[prefect_hex.models.project.ProjectStatusResponsePayload]</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>Array of run status payloads in the same format returned by the <code>GetRunStatus</code> endpoint.</p>"},{"location":"models/project/#prefect_hex.models.project.ProjectRunsResponsePayload.trace_id","title":"<code>trace_id: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>Hex trace ID to identify an API request. Provide this value to hex support with any API issues you encounter.</p>"},{"location":"models/project/#prefect_hex.models.project.ProjectStatusResponsePayload","title":"<code> ProjectStatusResponsePayload        </code>  <code>pydantic-model</code>","text":"<p>Response format returned by the getRunStatus endpoint</p> Source code in <code>prefect_hex/models/project.py</code> <pre><code>class ProjectStatusResponsePayload(BaseModel):\n    \"\"\"\n    Response format returned by the getRunStatus endpoint\n    \"\"\"\n\n    class Config:\n        extra = Extra.allow\n        allow_mutation = False\n\n    elapsed_time: float = Field(\n        default=...,\n        alias=\"elapsedTime\",\n        description=\"Total elapsed time for the project run in milliseconds.\",\n    )\n    end_time: Optional[datetime] = Field(\n        default=None,\n        alias=\"endTime\",\n        description=\"UTC timestamp of when the project run finished.\",\n    )\n    project_id: str = Field(\n        default=..., alias=\"projectId\", description=\"Unique ID for a Hex project.\"\n    )\n    run_id: str = Field(\n        default=..., alias=\"runId\", description=\"Unique ID for a run of a Hex project.\"\n    )\n    run_url: HttpUrl = Field(\n        default=...,\n        alias=\"runUrl\",\n        description=\"URL to view the current progress of the project run in the Hex UI.\",\n    )\n    start_time: datetime = Field(\n        default=...,\n        alias=\"startTime\",\n        description=\"UTC timestamp of when the project run started.\",\n    )\n    status: ProjectRunStatus\n    trace_id: str = Field(\n        default=...,\n        alias=\"traceId\",\n        description=(\n            \"Hex trace ID to identify an API request. Provide this value to hex support\"\n            \" with any API issues you encounter.\"\n        ),\n    )\n</code></pre>"},{"location":"models/project/#prefect_hex.models.project.ProjectStatusResponsePayload.elapsed_time","title":"<code>elapsed_time: float</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>Total elapsed time for the project run in milliseconds.</p>"},{"location":"models/project/#prefect_hex.models.project.ProjectStatusResponsePayload.end_time","title":"<code>end_time: datetime</code>  <code>pydantic-field</code>","text":"<p>UTC timestamp of when the project run finished.</p>"},{"location":"models/project/#prefect_hex.models.project.ProjectStatusResponsePayload.project_id","title":"<code>project_id: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>Unique ID for a Hex project.</p>"},{"location":"models/project/#prefect_hex.models.project.ProjectStatusResponsePayload.run_id","title":"<code>run_id: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>Unique ID for a run of a Hex project.</p>"},{"location":"models/project/#prefect_hex.models.project.ProjectStatusResponsePayload.run_url","title":"<code>run_url: HttpUrl</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>URL to view the current progress of the project run in the Hex UI.</p>"},{"location":"models/project/#prefect_hex.models.project.ProjectStatusResponsePayload.start_time","title":"<code>start_time: datetime</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>UTC timestamp of when the project run started.</p>"},{"location":"models/project/#prefect_hex.models.project.ProjectStatusResponsePayload.trace_id","title":"<code>trace_id: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>Hex trace ID to identify an API request. Provide this value to hex support with any API issues you encounter.</p>"},{"location":"models/project/#prefect_hex.models.project.RunProjectRequestBody","title":"<code> RunProjectRequestBody        </code>  <code>pydantic-model</code>","text":"Source code in <code>prefect_hex/models/project.py</code> <pre><code>class RunProjectRequestBody(BaseModel):\n    class Config:\n        extra = Extra.allow\n        extra = Extra.forbid\n        allow_mutation = False\n\n    dry_run: Optional[bool] = Field(\n        \"false\",\n        alias=\"dryRun\",\n        description=(\n            \"If specified, perform a dry run without actually executing the project.\"\n        ),\n    )\n    input_params: Optional[Dict[str, Any]] = Field(\n        None,\n        alias=\"inputParams\",\n        description=\"Optional input parameter value map for this project run.\",\n        example={\"numeric_input_1\": 123, \"text_input_1\": \"Hello World\"},\n    )\n    update_cache: Optional[bool] = Field(\n        \"false\",\n        alias=\"updateCache\",\n        description=(\n            \"When true, this run will update the cached state of the published app with\"\n            \" the latest run results.\\nAdditionally, any SQL cells that have caching\"\n            \" enabled will be re-executed as part of this run. Note\\nthat this cannot\"\n            \" be set to true if custom input parameters are provided.\"\n        ),\n    )\n</code></pre>"},{"location":"models/project/#prefect_hex.models.project.RunProjectRequestBody.dry_run","title":"<code>dry_run: bool</code>  <code>pydantic-field</code>","text":"<p>If specified, perform a dry run without actually executing the project.</p>"},{"location":"models/project/#prefect_hex.models.project.RunProjectRequestBody.input_params","title":"<code>input_params: Dict[str, Any]</code>  <code>pydantic-field</code>","text":"<p>Optional input parameter value map for this project run.</p>"},{"location":"models/project/#prefect_hex.models.project.RunProjectRequestBody.update_cache","title":"<code>update_cache: bool</code>  <code>pydantic-field</code>","text":"<p>When true, this run will update the cached state of the published app with the latest run results. Additionally, any SQL cells that have caching enabled will be re-executed as part of this run. Note that this cannot be set to true if custom input parameters are provided.</p>"}]}